/* MyServer.c generated by valac 0.10.0, the Vala compiler
 * generated from MyServer.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>


#define IRC_TYPE_MY_SERVER (irc_my_server_get_type ())
#define IRC_MY_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IRC_TYPE_MY_SERVER, IRCMyServer))
#define IRC_MY_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IRC_TYPE_MY_SERVER, IRCMyServerClass))
#define IRC_IS_MY_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IRC_TYPE_MY_SERVER))
#define IRC_IS_MY_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IRC_TYPE_MY_SERVER))
#define IRC_MY_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IRC_TYPE_MY_SERVER, IRCMyServerClass))

typedef struct _IRCMyServer IRCMyServer;
typedef struct _IRCMyServerClass IRCMyServerClass;
typedef struct _IRCMyServerPrivate IRCMyServerPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_source_unref0(var) ((var == NULL) ? NULL : (var = (g_source_unref (var), NULL)))
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))
#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))
typedef struct _irc_my_server_ConnectData irc_my_server_ConnectData;
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _IRCMyServer {
	GObject parent_instance;
	IRCMyServerPrivate * priv;
};

struct _IRCMyServerClass {
	GObjectClass parent_class;
	void (*on_disconnected) (IRCMyServer* self);
	void (*on_data_received) (IRCMyServer* self, const char* buffer, gsize len);
};

struct _IRCMyServerPrivate {
	char* _RealName;
	char* _Nickname;
	char* _Username;
	GSocketClient* _socketClient;
	char* _Host;
	guint16 _Port;
	guint _sourceID;
	GInetAddress* _Address;
	GSource* _source;
	GInetSocketAddress* _SocketAddress;
	GSocketConnection* _socketConnection;
	GDataInputStream* _inputStream;
	GIOChannel* _channel;
	GCancellable* _cancellable;
	GIOCondition _conditions;
};

struct _irc_my_server_ConnectData {
	int _state_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	IRCMyServer* self;
	GResolver* res;
	GList* results;
	GInetSocketAddress* _tmp0_;
	GSocketClient* _tmp1_;
	GSocketConnection* _tmp2_;
	GSocketConnection* _tmp3_;
	GError * __err;
	GError * _inner_error_;
};


static gpointer irc_my_server_parent_class = NULL;

GType irc_my_server_get_type (void) G_GNUC_CONST;
#define IRC_MY_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), IRC_TYPE_MY_SERVER, IRCMyServerPrivate))
enum  {
	IRC_MY_SERVER_DUMMY_PROPERTY,
	IRC_MY_SERVER_REAL_NAME,
	IRC_MY_SERVER_NICKNAME,
	IRC_MY_SERVER_USERNAME,
	IRC_MY_SERVER_HOST,
	IRC_MY_SERVER_ADDRESS,
	IRC_MY_SERVER_SOCKET_ADDRESS
};
IRCMyServer* irc_my_server_new (void);
IRCMyServer* irc_my_server_construct (GType object_type);
void irc_my_server_set_RealName (IRCMyServer* self, const char* value);
void irc_my_server_set_Nickname (IRCMyServer* self, const char* value);
void irc_my_server_set_Username (IRCMyServer* self, const char* value);
void irc_my_server_set_Host (IRCMyServer* self, const char* value);
void irc_my_server_set_Port (IRCMyServer* self, guint16 value);
static void irc_my_server_Connect_data_free (gpointer _data);
static void irc_my_server_Connect_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void irc_my_server_Connect (IRCMyServer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void irc_my_server_Connect_finish (IRCMyServer* self, GAsyncResult* _res_);
static gboolean irc_my_server_Connect_co (irc_my_server_ConnectData* data);
const char* irc_my_server_get_Host (IRCMyServer* self);
void irc_my_server_set_Address (IRCMyServer* self, GInetAddress* value);
GInetAddress* irc_my_server_get_Address (IRCMyServer* self);
guint16 irc_my_server_get_Port (IRCMyServer* self);
void irc_my_server_set_SocketAddress (IRCMyServer* self, GInetSocketAddress* value);
GInetSocketAddress* irc_my_server_get_SocketAddress (IRCMyServer* self);
void irc_my_server_Monitoring (IRCMyServer* self);
static void _g_list_free_g_object_unref (GList* self);
static gboolean irc_my_server_SocketCallback (IRCMyServer* self, GIOChannel* source, GIOCondition condition);
static gboolean _irc_my_server_SocketCallback_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
void irc_my_server_on_data_received (IRCMyServer* self, const char* buffer, gsize len);
void irc_my_server_Disconnect (IRCMyServer* self);
static void irc_my_server_Cleanup (IRCMyServer* self);
void irc_my_server_on_disconnected (IRCMyServer* self);
static void irc_my_server_real_on_disconnected (IRCMyServer* self);
static void irc_my_server_real_on_data_received (IRCMyServer* self, const char* buffer, gsize len);
const char* irc_my_server_get_RealName (IRCMyServer* self);
const char* irc_my_server_get_Nickname (IRCMyServer* self);
const char* irc_my_server_get_Username (IRCMyServer* self);
static void irc_my_server_finalize (GObject* obj);
static void irc_my_server_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void irc_my_server_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static void g_cclosure_user_marshal_VOID__STRING_ULONG (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

IRCMyServer* irc_my_server_construct (GType object_type) {
	IRCMyServer * self;
	GCancellable* _tmp0_;
	self = (IRCMyServer*) g_object_new (object_type, NULL);
	irc_my_server_set_RealName (self, "Ventzislav Dimitrov");
	irc_my_server_set_Nickname (self, "DeeveN");
	irc_my_server_set_Username (self, "DeeveN");
	irc_my_server_set_Host (self, "Hamburg.DE.EU.undernet.org");
	irc_my_server_set_Port (self, (guint16) 6667);
	self->priv->_cancellable = (_tmp0_ = g_cancellable_new (), _g_object_unref0 (self->priv->_cancellable), _tmp0_);
	return self;
}


IRCMyServer* irc_my_server_new (void) {
	return irc_my_server_construct (IRC_TYPE_MY_SERVER);
}


static void irc_my_server_Connect_data_free (gpointer _data) {
	irc_my_server_ConnectData* data;
	data = _data;
	g_object_unref (data->self);
	g_slice_free (irc_my_server_ConnectData, data);
}


void irc_my_server_Connect (IRCMyServer* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	irc_my_server_ConnectData* _data_;
	_data_ = g_slice_new0 (irc_my_server_ConnectData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, irc_my_server_Connect);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, irc_my_server_Connect_data_free);
	_data_->self = g_object_ref (self);
	irc_my_server_Connect_co (_data_);
}


void irc_my_server_Connect_finish (IRCMyServer* self, GAsyncResult* _res_) {
	irc_my_server_ConnectData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void irc_my_server_Connect_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	irc_my_server_ConnectData* data;
	data = _user_data_;
	data->_res_ = _res_;
	irc_my_server_Connect_co (data);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _g_list_free_g_object_unref (GList* self) {
	g_list_foreach (self, (GFunc) g_object_unref, NULL);
	g_list_free (self);
}


static gboolean irc_my_server_Connect_co (irc_my_server_ConnectData* data) {
	switch (data->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	fprintf (stdout, "connect fired\n");
	data->res = _g_object_ref0 (g_resolver_get_default ());
	data->results = g_resolver_lookup_by_name (data->res, data->self->priv->_Host, data->self->priv->_cancellable, &data->_inner_error_);
	if (data->_inner_error_ != NULL) {
		_g_object_unref0 (data->res);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, data->_inner_error_->message, g_quark_to_string (data->_inner_error_->domain), data->_inner_error_->code);
		g_clear_error (&data->_inner_error_);
		return FALSE;
	}
	if (data->results != NULL) {
		fprintf (stdout, "results != null\n");
		irc_my_server_set_Address (data->self, G_INET_ADDRESS ((GInetAddress*) g_list_nth_data (data->results, (guint) 0)));
		irc_my_server_set_SocketAddress (data->self, data->_tmp0_ = (GInetSocketAddress*) g_inet_socket_address_new (data->self->priv->_Address, data->self->priv->_Port));
		_g_object_unref0 (data->_tmp0_);
	}
	{
		data->self->priv->_socketClient = (data->_tmp1_ = g_socket_client_new (), _g_object_unref0 (data->self->priv->_socketClient), data->_tmp1_);
		g_socket_client_set_protocol (data->self->priv->_socketClient, G_SOCKET_PROTOCOL_TCP);
		data->_tmp2_ = g_socket_client_connect (data->self->priv->_socketClient, (GSocketConnectable*) data->self->priv->_SocketAddress, NULL, &data->_inner_error_);
		if (data->_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		data->self->priv->_socketConnection = (data->_tmp3_ = _g_object_ref0 (data->_tmp2_), _g_object_unref0 (data->self->priv->_socketConnection), data->_tmp3_);
		fprintf (stdout, "socketConnection ist verbunden\n");
		irc_my_server_Monitoring (data->self);
	}
	goto __finally0;
	__catch0_g_error:
	{
		data->__err = data->_inner_error_;
		data->_inner_error_ = NULL;
		{
			fprintf (stdout, "fehler\n");
		}
	}
	__finally0:
	if (data->_inner_error_ != NULL) {
		__g_list_free_g_object_unref0 (data->results);
		_g_object_unref0 (data->res);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, data->_inner_error_->message, g_quark_to_string (data->_inner_error_->domain), data->_inner_error_->code);
		g_clear_error (&data->_inner_error_);
		return FALSE;
	}
	__g_list_free_g_object_unref0 (data->results);
	_g_object_unref0 (data->res);
	{
		if (data->_state_ == 0) {
			g_simple_async_result_complete_in_idle (data->_async_result);
		} else {
			g_simple_async_result_complete (data->_async_result);
		}
		g_object_unref (data->_async_result);
		return FALSE;
	}
}


static gboolean _irc_my_server_SocketCallback_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = irc_my_server_SocketCallback (self, source, condition);
	return result;
}


void irc_my_server_Monitoring (IRCMyServer* self) {
	GCancellable* _tmp0_;
	GDataInputStream* _tmp1_;
	GIOChannel* _tmp2_;
	g_return_if_fail (self != NULL);
	self->priv->_cancellable = (_tmp0_ = NULL, _g_object_unref0 (self->priv->_cancellable), _tmp0_);
	g_socket_set_blocking (g_socket_connection_get_socket (self->priv->_socketConnection), FALSE);
	self->priv->_inputStream = (_tmp1_ = g_data_input_stream_new (g_io_stream_get_input_stream ((GIOStream*) self->priv->_socketConnection)), _g_object_unref0 (self->priv->_inputStream), _tmp1_);
	fprintf (stdout, "inputStream ist verbunden\n");
	self->priv->_conditions = ((G_IO_IN | G_IO_HUP) | G_IO_ERR) | G_IO_NVAL;
	self->priv->_channel = (_tmp2_ = g_io_channel_unix_new (g_socket_get_fd (g_socket_connection_get_socket (self->priv->_socketConnection))), _g_io_channel_unref0 (self->priv->_channel), _tmp2_);
	g_io_channel_init (self->priv->_channel);
	fprintf (stdout, "channel ist verbunden\n");
	self->priv->_sourceID = g_io_add_watch (self->priv->_channel, self->priv->_conditions, _irc_my_server_SocketCallback_gio_func, self);
}


static gboolean irc_my_server_SocketCallback (IRCMyServer* self, GIOChannel* source, GIOCondition condition) {
	gboolean result = FALSE;
	gboolean res;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	res = TRUE;
	switch (condition) {
		case G_IO_IN:
		{
			gsize length;
			GString* message;
			length = (gsize) (-1);
			message = g_string_new ("");
			while (TRUE) {
				if (!(length != 0)) {
					break;
				}
				{
					char* buffer;
					buffer = g_data_input_stream_read_line (self->priv->_inputStream, &length, NULL, &_inner_error_);
					if (_inner_error_ != NULL) {
						goto __catch1_g_error;
					}
					if (buffer != NULL) {
						g_string_append_printf (message, "%s\n", buffer);
					}
					_g_free0 (buffer);
				}
				goto __finally1;
				__catch1_g_error:
				{
					g_clear_error (&_inner_error_);
					_inner_error_ = NULL;
					{
						fprintf (stdout, "Err\n");
					}
				}
				__finally1:
				if (_inner_error_ != NULL) {
					_g_string_free0 (message);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
			}
			if (message->len > 0) {
				irc_my_server_on_data_received (self, message->str, (gsize) message->len);
			} else {
				irc_my_server_Disconnect (self);
			}
			_g_string_free0 (message);
			break;
		}
	}
	result = res;
	return result;
}


void irc_my_server_Disconnect (IRCMyServer* self) {
	g_return_if_fail (self != NULL);
	irc_my_server_Cleanup (self);
	irc_my_server_on_disconnected (self);
}


static void irc_my_server_real_on_disconnected (IRCMyServer* self) {
	g_return_if_fail (self != NULL);
	g_signal_emit_by_name (self, "disconnected");
}


void irc_my_server_on_disconnected (IRCMyServer* self) {
	IRC_MY_SERVER_GET_CLASS (self)->on_disconnected (self);
}


static void irc_my_server_Cleanup (IRCMyServer* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		g_source_remove_by_user_data (self);
		if (self->priv->_sourceID != 0) {
			g_source_remove (self->priv->_sourceID);
			self->priv->_sourceID = (guint) 0;
		}
		if (self->priv->_source != NULL) {
			GSource* _tmp0_;
			g_source_destroy (self->priv->_source);
			self->priv->_source = (_tmp0_ = NULL, _g_source_unref0 (self->priv->_source), _tmp0_);
		}
		if (self->priv->_socketConnection != NULL) {
			GDataInputStream* _tmp1_;
			GIOChannel* _tmp2_;
			GSocketConnection* _tmp3_;
			self->priv->_inputStream = (_tmp1_ = NULL, _g_object_unref0 (self->priv->_inputStream), _tmp1_);
			self->priv->_channel = (_tmp2_ = NULL, _g_io_channel_unref0 (self->priv->_channel), _tmp2_);
			g_io_stream_close ((GIOStream*) self->priv->_socketConnection, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch2_g_error;
			}
			self->priv->_socketConnection = (_tmp3_ = NULL, _g_object_unref0 (self->priv->_socketConnection), _tmp3_);
		}
		if (self->priv->_socketClient != NULL) {
			GSocketClient* _tmp4_;
			self->priv->_socketClient = (_tmp4_ = NULL, _g_object_unref0 (self->priv->_socketClient), _tmp4_);
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("MyServer.vala:159: error cleanup: %s", err->message);
			_g_error_free0 (err);
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void irc_my_server_real_on_data_received (IRCMyServer* self, const char* buffer, gsize len) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (buffer != NULL);
}


void irc_my_server_on_data_received (IRCMyServer* self, const char* buffer, gsize len) {
	IRC_MY_SERVER_GET_CLASS (self)->on_data_received (self, buffer, len);
}


const char* irc_my_server_get_RealName (IRCMyServer* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_RealName;
	return result;
}


void irc_my_server_set_RealName (IRCMyServer* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_RealName = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_RealName), _tmp0_);
	g_object_notify ((GObject *) self, "RealName");
}


const char* irc_my_server_get_Nickname (IRCMyServer* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Nickname;
	return result;
}


void irc_my_server_set_Nickname (IRCMyServer* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_Nickname = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_Nickname), _tmp0_);
	g_object_notify ((GObject *) self, "Nickname");
}


const char* irc_my_server_get_Username (IRCMyServer* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Username;
	return result;
}


void irc_my_server_set_Username (IRCMyServer* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_Username = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_Username), _tmp0_);
	g_object_notify ((GObject *) self, "Username");
}


const char* irc_my_server_get_Host (IRCMyServer* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Host;
	return result;
}


void irc_my_server_set_Host (IRCMyServer* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_Host = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_Host), _tmp0_);
	g_object_notify ((GObject *) self, "Host");
}


guint16 irc_my_server_get_Port (IRCMyServer* self) {
	guint16 result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_Port;
	return result;
}


void irc_my_server_set_Port (IRCMyServer* self, guint16 value) {
	g_return_if_fail (self != NULL);
	self->priv->_Port = value;
}


GInetAddress* irc_my_server_get_Address (IRCMyServer* self) {
	GInetAddress* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Address;
	return result;
}


void irc_my_server_set_Address (IRCMyServer* self, GInetAddress* value) {
	GInetAddress* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_Address = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_Address), _tmp0_);
	g_object_notify ((GObject *) self, "Address");
}


GInetSocketAddress* irc_my_server_get_SocketAddress (IRCMyServer* self) {
	GInetSocketAddress* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_SocketAddress;
	return result;
}


void irc_my_server_set_SocketAddress (IRCMyServer* self, GInetSocketAddress* value) {
	GInetSocketAddress* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_SocketAddress = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_SocketAddress), _tmp0_);
	g_object_notify ((GObject *) self, "SocketAddress");
}


static void irc_my_server_class_init (IRCMyServerClass * klass) {
	irc_my_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IRCMyServerPrivate));
	IRC_MY_SERVER_CLASS (klass)->on_disconnected = irc_my_server_real_on_disconnected;
	IRC_MY_SERVER_CLASS (klass)->on_data_received = irc_my_server_real_on_data_received;
	G_OBJECT_CLASS (klass)->get_property = irc_my_server_get_property;
	G_OBJECT_CLASS (klass)->set_property = irc_my_server_set_property;
	G_OBJECT_CLASS (klass)->finalize = irc_my_server_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), IRC_MY_SERVER_REAL_NAME, g_param_spec_string ("RealName", "RealName", "RealName", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), IRC_MY_SERVER_NICKNAME, g_param_spec_string ("Nickname", "Nickname", "Nickname", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), IRC_MY_SERVER_USERNAME, g_param_spec_string ("Username", "Username", "Username", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), IRC_MY_SERVER_HOST, g_param_spec_string ("Host", "Host", "Host", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), IRC_MY_SERVER_ADDRESS, g_param_spec_object ("Address", "Address", "Address", G_TYPE_INET_ADDRESS, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), IRC_MY_SERVER_SOCKET_ADDRESS, g_param_spec_object ("SocketAddress", "SocketAddress", "SocketAddress", G_TYPE_INET_SOCKET_ADDRESS, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("data_received", IRC_TYPE_MY_SERVER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_ULONG, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_ULONG);
	g_signal_new ("disconnected", IRC_TYPE_MY_SERVER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void irc_my_server_instance_init (IRCMyServer * self) {
	self->priv = IRC_MY_SERVER_GET_PRIVATE (self);
	self->priv->_sourceID = (guint) 0;
	self->priv->_source = NULL;
}


static void irc_my_server_finalize (GObject* obj) {
	IRCMyServer * self;
	self = IRC_MY_SERVER (obj);
	_g_free0 (self->priv->_RealName);
	_g_free0 (self->priv->_Nickname);
	_g_free0 (self->priv->_Username);
	_g_object_unref0 (self->priv->_socketClient);
	_g_free0 (self->priv->_Host);
	_g_object_unref0 (self->priv->_Address);
	_g_source_unref0 (self->priv->_source);
	_g_object_unref0 (self->priv->_SocketAddress);
	_g_object_unref0 (self->priv->_socketConnection);
	_g_object_unref0 (self->priv->_inputStream);
	_g_io_channel_unref0 (self->priv->_channel);
	_g_object_unref0 (self->priv->_cancellable);
	G_OBJECT_CLASS (irc_my_server_parent_class)->finalize (obj);
}


GType irc_my_server_get_type (void) {
	static volatile gsize irc_my_server_type_id__volatile = 0;
	if (g_once_init_enter (&irc_my_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IRCMyServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) irc_my_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IRCMyServer), 0, (GInstanceInitFunc) irc_my_server_instance_init, NULL };
		GType irc_my_server_type_id;
		irc_my_server_type_id = g_type_register_static (G_TYPE_OBJECT, "IRCMyServer", &g_define_type_info, 0);
		g_once_init_leave (&irc_my_server_type_id__volatile, irc_my_server_type_id);
	}
	return irc_my_server_type_id__volatile;
}


static void irc_my_server_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	IRCMyServer * self;
	self = IRC_MY_SERVER (object);
	switch (property_id) {
		case IRC_MY_SERVER_REAL_NAME:
		g_value_set_string (value, irc_my_server_get_RealName (self));
		break;
		case IRC_MY_SERVER_NICKNAME:
		g_value_set_string (value, irc_my_server_get_Nickname (self));
		break;
		case IRC_MY_SERVER_USERNAME:
		g_value_set_string (value, irc_my_server_get_Username (self));
		break;
		case IRC_MY_SERVER_HOST:
		g_value_set_string (value, irc_my_server_get_Host (self));
		break;
		case IRC_MY_SERVER_ADDRESS:
		g_value_set_object (value, irc_my_server_get_Address (self));
		break;
		case IRC_MY_SERVER_SOCKET_ADDRESS:
		g_value_set_object (value, irc_my_server_get_SocketAddress (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void irc_my_server_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	IRCMyServer * self;
	self = IRC_MY_SERVER (object);
	switch (property_id) {
		case IRC_MY_SERVER_REAL_NAME:
		irc_my_server_set_RealName (self, g_value_get_string (value));
		break;
		case IRC_MY_SERVER_NICKNAME:
		irc_my_server_set_Nickname (self, g_value_get_string (value));
		break;
		case IRC_MY_SERVER_USERNAME:
		irc_my_server_set_Username (self, g_value_get_string (value));
		break;
		case IRC_MY_SERVER_HOST:
		irc_my_server_set_Host (self, g_value_get_string (value));
		break;
		case IRC_MY_SERVER_ADDRESS:
		irc_my_server_set_Address (self, g_value_get_object (value));
		break;
		case IRC_MY_SERVER_SOCKET_ADDRESS:
		irc_my_server_set_SocketAddress (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



static void g_cclosure_user_marshal_VOID__STRING_ULONG (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_ULONG) (gpointer data1, const char* arg_1, gsize arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_ULONG callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_ULONG) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_ulong (param_values + 2), data2);
}



